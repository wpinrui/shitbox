<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Shitbox Map Painter</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: #1a1a2e;
      color: #eee;
      display: flex;
      height: 100vh;
      overflow: hidden;
    }

    /* Sidebar */
    .sidebar {
      width: 320px;
      background: #16213e;
      display: flex;
      flex-direction: column;
      border-right: 2px solid #0f3460;
    }
    .sidebar h2 {
      padding: 12px;
      background: #0f3460;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    /* Controls */
    .controls {
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      border-bottom: 1px solid #0f3460;
    }
    .controls label {
      font-size: 12px;
      color: #888;
    }
    .controls input, .controls select {
      padding: 6px 10px;
      background: #1a1a2e;
      border: 1px solid #0f3460;
      color: #eee;
      border-radius: 4px;
    }
    .controls button {
      padding: 8px 12px;
      background: #e94560;
      border: none;
      color: white;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 600;
    }
    .controls button:hover { background: #ff6b6b; }
    .controls button.secondary {
      background: #0f3460;
    }
    .controls button.secondary:hover { background: #1a4a8a; }

    .row { display: flex; gap: 8px; align-items: center; }
    .row input { flex: 1; width: 60px; }

    /* Palette */
    .palette-container {
      flex: 1;
      overflow-y: auto;
      padding: 8px;
    }
    .palette {
      display: grid;
      grid-template-columns: repeat(10, 1fr);
      gap: 2px;
    }
    .palette-tile {
      width: 28px;
      height: 28px;
      border: 2px solid transparent;
      cursor: pointer;
      image-rendering: pixelated;
      position: relative;
    }
    .palette-tile:hover { border-color: #ff6b6b; }
    .palette-tile.selected { border-color: #e94560; box-shadow: 0 0 8px #e94560; }
    .palette-tile .tile-index {
      position: absolute;
      bottom: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      font-size: 7px;
      padding: 1px 2px;
      color: #fff;
    }

    /* Selected tile preview */
    .selected-preview {
      padding: 12px;
      border-bottom: 1px solid #0f3460;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .selected-preview .preview-tile {
      width: 48px;
      height: 48px;
      border: 2px solid #e94560;
      image-rendering: pixelated;
    }
    .selected-preview .info {
      font-size: 12px;
    }
    .selected-preview .info strong {
      color: #e94560;
      font-size: 18px;
    }

    /* Main canvas area */
    .main {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .toolbar {
      padding: 8px 12px;
      background: #16213e;
      display: flex;
      gap: 12px;
      align-items: center;
      border-bottom: 1px solid #0f3460;
    }
    .toolbar label {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 13px;
    }
    .toolbar input[type="checkbox"] {
      width: 16px;
      height: 16px;
    }
    .canvas-container {
      flex: 1;
      overflow: auto;
      background: #0d0d1a;
      padding: 20px;
    }
    #mapCanvas {
      image-rendering: pixelated;
      cursor: crosshair;
    }

    /* Locations panel */
    .locations-panel {
      width: 280px;
      background: #16213e;
      border-left: 2px solid #0f3460;
      display: flex;
      flex-direction: column;
    }
    .locations-list {
      flex: 1;
      overflow-y: auto;
      padding: 8px;
    }
    .location-item {
      padding: 8px;
      margin-bottom: 4px;
      background: #1a1a2e;
      border-radius: 4px;
      font-size: 12px;
      border-left: 3px solid #0f3460;
    }
    .location-item.assigned { border-left-color: #4caf50; }
    .location-item .name { font-weight: 600; color: #e94560; }
    .location-item .coords { color: #888; font-size: 11px; margin-top: 4px; }

    /* Export modal */
    .modal {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.8);
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    .modal.active { display: flex; }
    .modal-content {
      background: #16213e;
      padding: 20px;
      border-radius: 8px;
      max-width: 800px;
      max-height: 80vh;
      overflow: auto;
    }
    .modal-content h3 { margin-bottom: 12px; }
    .modal-content textarea {
      width: 100%;
      height: 400px;
      background: #1a1a2e;
      border: 1px solid #0f3460;
      color: #eee;
      font-family: monospace;
      font-size: 11px;
      padding: 8px;
    }
    .modal-content button { margin-top: 12px; }
  </style>
</head>
<body>
  <!-- Sidebar: Palette & Controls -->
  <div class="sidebar">
    <h2>Map Settings</h2>
    <div class="controls">
      <div class="row">
        <div>
          <label>Width</label>
          <input type="number" id="gridWidth" value="40" min="10" max="100">
        </div>
        <div>
          <label>Height</label>
          <input type="number" id="gridHeight" value="30" min="10" max="100">
        </div>
      </div>
      <button onclick="resizeGrid()">Resize Grid</button>
      <button class="secondary" onclick="clearGrid()">Clear Grid</button>
      <button class="secondary" onclick="exportMap()">Export JSON</button>
    </div>

    <div class="selected-preview">
      <div class="preview-tile" id="previewTile"></div>
      <div class="info">
        <div>Selected Tile</div>
        <strong id="selectedIndex">0</strong>
      </div>
    </div>

    <h2>Tile Palette</h2>
    <div class="palette-container">
      <div class="palette" id="palette"></div>
    </div>
  </div>

  <!-- Main Canvas -->
  <div class="main">
    <div class="toolbar">
      <label>
        <input type="checkbox" id="showLabels" checked onchange="render()">
        Show Cell Labels
      </label>
      <label>
        <input type="checkbox" id="showGrid" checked onchange="render()">
        Show Grid Lines
      </label>
      <label>
        <input type="checkbox" id="highlightLocations" checked onchange="render()">
        Highlight Locations
      </label>
      <span style="margin-left: auto; font-size: 12px; color: #888;">
        Left-click: Paint | Right-click: Erase (grass) | Drag: Paint multiple
      </span>
    </div>
    <div class="canvas-container">
      <canvas id="mapCanvas"></canvas>
    </div>
  </div>

  <!-- Locations Panel -->
  <div class="locations-panel">
    <h2>Locations to Paint</h2>
    <div class="controls">
      <label>Assign cells to location:</label>
      <select id="assignLocation">
        <option value="">-- Select Location --</option>
      </select>
      <div style="font-size: 11px; color: #888; margin-top: 4px;">
        After painting, note down which cells belong to each location
      </div>
    </div>
    <div class="locations-list" id="locationsList"></div>
  </div>

  <!-- Export Modal -->
  <div class="modal" id="exportModal">
    <div class="modal-content">
      <h3>Exported Map Data</h3>
      <textarea id="exportData" readonly></textarea>
      <button onclick="copyExport()">Copy to Clipboard</button>
      <button class="secondary" onclick="closeModal()">Close</button>
    </div>
  </div>

  <script>
    // Configuration
    const TILE_SIZE = 16;
    const TILE_SPACING = 1;
    const TILESET_WIDTH = 37;
    const TILESET_HEIGHT = 28;
    const TILE_WITH_SPACING = TILE_SIZE + TILE_SPACING;
    const DISPLAY_TILE_SIZE = 24; // Size to display on canvas

    // Tileset image
    const tilesetImg = new Image();
    tilesetImg.src = '../src/assets/tilesets/modern-city/Tilemap/tilemap_packed.png';

    // State
    let gridWidth = 40;
    let gridHeight = 30;
    let selectedTile = 111; // Default: grass
    let grid = []; // 2D array of tile indices
    let locationAssignments = {}; // cellKey -> locationId
    let isPainting = false;

    // Known tile types from map.json
    const TILE_TYPES = {
      grass: 111,
      pavement: 74,
      road_h: 673,
      road_v: 710,
      road_intersection: 711,
      road_corner_tl: 672,
      road_corner_tr: 674,
      road_corner_bl: 746,
      road_corner_br: 748,
      brick_red: 0,
      brick_grey: 37,
      concrete: 148,
      wood_floor: 185,
      fence_h: 481,
      fence_v: 518
    };

    // Locations that need to be painted
    const LOCATIONS = [
      { id: 'scrapyard', name: 'Scrapyard', desc: 'Work for cash, scavenge parts, buy junkers', style: 'industrial' },
      { id: 'parking_lot', name: 'Parking Lot', desc: 'Park your car, retrieve towed vehicles', style: 'parking' },
      { id: 'gas_station', name: 'Gas Station', desc: 'Refuel your car', style: 'commercial' },
      { id: 'garage', name: 'Garage', desc: 'Store cars, basic repairs, DIY work', style: 'industrial' },
      { id: 'workshop', name: 'Workshop', desc: 'Major repairs, engine work', style: 'industrial' },
      { id: 'bank', name: 'Bank', desc: 'Savings, loans, investments', style: 'commercial' },
      { id: 'school', name: 'Driving School', desc: 'Driving lessons, license tests', style: 'commercial' },
      { id: 'apartments', name: 'Apartments', desc: 'Rent a place, better sleep', style: 'residential' },
      { id: 'car_wash', name: 'Car Wash', desc: 'Entry-level job washing cars', style: 'commercial' },
      { id: 'auction', name: 'Auction House', desc: 'Bid on cars, consign vehicles', style: 'commercial' },
      { id: 'showroom', name: 'Showroom', desc: 'High-end dealership, sales job', style: 'commercial' },
      { id: 'diner', name: 'Diner', desc: 'Eat food, restore energy (NEW)', style: 'commercial' },
      { id: 'gym', name: 'Gym', desc: 'Work out, increase fitness (NEW)', style: 'commercial' },
      { id: 'library', name: 'Library', desc: 'Study, increase knowledge (NEW)', style: 'commercial' },
      { id: 'bar', name: 'Bar', desc: 'Socialize, practice charisma (NEW)', style: 'commercial' },
      { id: 'motel', name: 'Motel', desc: 'Cheap sleep option (NEW)', style: 'residential' },
      { id: 'dealership', name: 'Used Car Lot', desc: 'Buy/sell used cars (NEW)', style: 'commercial' },
      { id: 'highway_entrance', name: 'Highway Entrance', desc: 'Road trips to other cities (NEW)', style: 'parking' },
    ];

    // Canvas
    const canvas = document.getElementById('mapCanvas');
    const ctx = canvas.getContext('2d');

    // Initialize
    tilesetImg.onload = function() {
      initPalette();
      initGrid();
      initLocationsList();
      render();
    };

    function initPalette() {
      const palette = document.getElementById('palette');
      const totalTiles = TILESET_WIDTH * TILESET_HEIGHT;

      for (let i = 0; i < totalTiles; i++) {
        const tile = document.createElement('div');
        tile.className = 'palette-tile';
        tile.dataset.index = i;

        // Draw tile to small canvas
        const tileCanvas = document.createElement('canvas');
        tileCanvas.width = TILE_SIZE;
        tileCanvas.height = TILE_SIZE;
        const tileCtx = tileCanvas.getContext('2d');

        const col = i % TILESET_WIDTH;
        const row = Math.floor(i / TILESET_WIDTH);
        const sx = col * TILE_WITH_SPACING;
        const sy = row * TILE_WITH_SPACING;

        tileCtx.drawImage(tilesetImg, sx, sy, TILE_SIZE, TILE_SIZE, 0, 0, TILE_SIZE, TILE_SIZE);

        tile.style.backgroundImage = `url(${tileCanvas.toDataURL()})`;
        tile.style.backgroundSize = 'cover';

        // Add index label
        const label = document.createElement('span');
        label.className = 'tile-index';
        label.textContent = i;
        tile.appendChild(label);

        tile.onclick = () => selectTile(i);
        palette.appendChild(tile);
      }

      selectTile(111); // Default to grass
    }

    function selectTile(index) {
      selectedTile = index;

      // Update UI
      document.querySelectorAll('.palette-tile').forEach(t => t.classList.remove('selected'));
      document.querySelector(`.palette-tile[data-index="${index}"]`)?.classList.add('selected');
      document.getElementById('selectedIndex').textContent = index;

      // Update preview
      const preview = document.getElementById('previewTile');
      const col = index % TILESET_WIDTH;
      const row = Math.floor(index / TILESET_WIDTH);
      const sx = col * TILE_WITH_SPACING;
      const sy = row * TILE_WITH_SPACING;

      const previewCanvas = document.createElement('canvas');
      previewCanvas.width = TILE_SIZE;
      previewCanvas.height = TILE_SIZE;
      const previewCtx = previewCanvas.getContext('2d');
      previewCtx.drawImage(tilesetImg, sx, sy, TILE_SIZE, TILE_SIZE, 0, 0, TILE_SIZE, TILE_SIZE);
      preview.style.backgroundImage = `url(${previewCanvas.toDataURL()})`;
      preview.style.backgroundSize = 'cover';
    }

    function initGrid() {
      grid = [];
      for (let y = 0; y < gridHeight; y++) {
        const row = [];
        for (let x = 0; x < gridWidth; x++) {
          row.push(TILE_TYPES.grass);
        }
        grid.push(row);
      }

      canvas.width = gridWidth * DISPLAY_TILE_SIZE;
      canvas.height = gridHeight * DISPLAY_TILE_SIZE;
    }

    function initLocationsList() {
      const list = document.getElementById('locationsList');
      const select = document.getElementById('assignLocation');

      list.innerHTML = '';
      select.innerHTML = '<option value="">-- Select Location --</option>';

      LOCATIONS.forEach(loc => {
        // Add to list
        const item = document.createElement('div');
        item.className = 'location-item';
        item.id = `loc-${loc.id}`;
        item.innerHTML = `
          <div class="name">${loc.name}</div>
          <div>${loc.desc}</div>
          <div class="coords" id="coords-${loc.id}">Style: ${loc.style}</div>
        `;
        list.appendChild(item);

        // Add to select
        const option = document.createElement('option');
        option.value = loc.id;
        option.textContent = loc.name;
        select.appendChild(option);
      });
    }

    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.imageSmoothingEnabled = false;

      const showLabels = document.getElementById('showLabels').checked;
      const showGrid = document.getElementById('showGrid').checked;
      const highlightLocs = document.getElementById('highlightLocations').checked;

      // Draw tiles
      for (let y = 0; y < gridHeight; y++) {
        for (let x = 0; x < gridWidth; x++) {
          const tileIndex = grid[y][x];
          const col = tileIndex % TILESET_WIDTH;
          const row = Math.floor(tileIndex / TILESET_WIDTH);
          const sx = col * TILE_WITH_SPACING;
          const sy = row * TILE_WITH_SPACING;

          ctx.drawImage(
            tilesetImg,
            sx, sy, TILE_SIZE, TILE_SIZE,
            x * DISPLAY_TILE_SIZE, y * DISPLAY_TILE_SIZE, DISPLAY_TILE_SIZE, DISPLAY_TILE_SIZE
          );

          // Highlight assigned locations
          const cellKey = `${x},${y}`;
          if (highlightLocs && locationAssignments[cellKey]) {
            ctx.fillStyle = 'rgba(233, 69, 96, 0.3)';
            ctx.fillRect(x * DISPLAY_TILE_SIZE, y * DISPLAY_TILE_SIZE, DISPLAY_TILE_SIZE, DISPLAY_TILE_SIZE);
          }
        }
      }

      // Draw grid lines
      if (showGrid) {
        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
        ctx.lineWidth = 1;
        for (let x = 0; x <= gridWidth; x++) {
          ctx.beginPath();
          ctx.moveTo(x * DISPLAY_TILE_SIZE, 0);
          ctx.lineTo(x * DISPLAY_TILE_SIZE, canvas.height);
          ctx.stroke();
        }
        for (let y = 0; y <= gridHeight; y++) {
          ctx.beginPath();
          ctx.moveTo(0, y * DISPLAY_TILE_SIZE);
          ctx.lineTo(canvas.width, y * DISPLAY_TILE_SIZE);
          ctx.stroke();
        }
      }

      // Draw cell labels
      if (showLabels) {
        ctx.font = '9px monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        for (let y = 0; y < gridHeight; y++) {
          for (let x = 0; x < gridWidth; x++) {
            const label = getCellLabel(x, y);
            const cx = x * DISPLAY_TILE_SIZE + DISPLAY_TILE_SIZE / 2;
            const cy = y * DISPLAY_TILE_SIZE + DISPLAY_TILE_SIZE / 2;

            // Background
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.fillRect(cx - 10, cy - 6, 20, 12);

            // Text
            ctx.fillStyle = '#fff';
            ctx.fillText(label, cx, cy);
          }
        }
      }
    }

    function getCellLabel(x, y) {
      // Convert to A1, B2 style labels
      // Columns: A-Z, then AA-AZ, etc.
      let colLabel = '';
      let col = x;
      do {
        colLabel = String.fromCharCode(65 + (col % 26)) + colLabel;
        col = Math.floor(col / 26) - 1;
      } while (col >= 0);

      return `${colLabel}${y + 1}`;
    }

    function getGridPosition(e) {
      const rect = canvas.getBoundingClientRect();
      const x = Math.floor((e.clientX - rect.left) / DISPLAY_TILE_SIZE);
      const y = Math.floor((e.clientY - rect.top) / DISPLAY_TILE_SIZE);
      return { x: Math.max(0, Math.min(x, gridWidth - 1)), y: Math.max(0, Math.min(y, gridHeight - 1)) };
    }

    function paintTile(x, y, tileIndex) {
      if (grid[y] && grid[y][x] !== undefined) {
        grid[y][x] = tileIndex;

        // Check location assignment
        const assignLoc = document.getElementById('assignLocation').value;
        if (assignLoc && tileIndex !== TILE_TYPES.grass) {
          locationAssignments[`${x},${y}`] = assignLoc;
        } else if (tileIndex === TILE_TYPES.grass) {
          delete locationAssignments[`${x},${y}`];
        }

        render();
      }
    }

    // Mouse events
    canvas.addEventListener('mousedown', (e) => {
      e.preventDefault();
      isPainting = true;
      const pos = getGridPosition(e);
      const tile = e.button === 2 ? TILE_TYPES.grass : selectedTile;
      paintTile(pos.x, pos.y, tile);
    });

    canvas.addEventListener('mousemove', (e) => {
      if (!isPainting) return;
      const pos = getGridPosition(e);
      const tile = e.buttons === 2 ? TILE_TYPES.grass : selectedTile;
      paintTile(pos.x, pos.y, tile);
    });

    canvas.addEventListener('mouseup', () => isPainting = false);
    canvas.addEventListener('mouseleave', () => isPainting = false);
    canvas.addEventListener('contextmenu', (e) => e.preventDefault());

    // Control functions
    function resizeGrid() {
      gridWidth = parseInt(document.getElementById('gridWidth').value) || 40;
      gridHeight = parseInt(document.getElementById('gridHeight').value) || 30;
      initGrid();
      render();
    }

    function clearGrid() {
      if (confirm('Clear entire grid? This cannot be undone.')) {
        initGrid();
        locationAssignments = {};
        render();
      }
    }

    function exportMap() {
      // Build the layers array
      const layers = [];
      for (let y = 0; y < gridHeight; y++) {
        layers.push([...grid[y]]);
      }

      // Group location assignments by location
      const locationBounds = {};
      for (const [cellKey, locId] of Object.entries(locationAssignments)) {
        const [x, y] = cellKey.split(',').map(Number);
        if (!locationBounds[locId]) {
          locationBounds[locId] = { minX: x, maxX: x, minY: y, maxY: y, cells: [] };
        }
        locationBounds[locId].minX = Math.min(locationBounds[locId].minX, x);
        locationBounds[locId].maxX = Math.max(locationBounds[locId].maxX, x);
        locationBounds[locId].minY = Math.min(locationBounds[locId].minY, y);
        locationBounds[locId].maxY = Math.max(locationBounds[locId].maxY, y);
        locationBounds[locId].cells.push({ x, y, label: getCellLabel(x, y) });
      }

      const exportData = {
        gridSize: { width: gridWidth, height: gridHeight },
        tileGrid: layers,
        locationBounds: locationBounds,
        instructions: "Copy tileGrid to map.json layers. Update location bounds from locationBounds."
      };

      document.getElementById('exportData').value = JSON.stringify(exportData, null, 2);
      document.getElementById('exportModal').classList.add('active');
    }

    function copyExport() {
      const textarea = document.getElementById('exportData');
      textarea.select();
      document.execCommand('copy');
      alert('Copied to clipboard!');
    }

    function closeModal() {
      document.getElementById('exportModal').classList.remove('active');
    }
  </script>
</body>
</html>
